<template>
  <link rel="stylesheet" href="goyop:///contents/common/album-template/goyo-richtext.css">
  <style class="wrap">
    .wrap-point::after, .newline::after {
      left: -2000px;
      width: 4000px;
    }
  </style>
  <style class="fontfamily"></style>
  <div class="base">
    <div class="text"></div>
  </div>
</template>
<script>
const GoyoRichText = (function() {
  'use strict';

  let importDoc = document.currentScript.ownerDocument;
  let template = importDoc.querySelector('template');

  const { remote } = require('electron');
  require('quill-delta-to-html/dist/commonjs/OpAttributeSanitizer').OpAttributeSanitizer.IsValidSize = function(size) {
    return !!size.match(/^[a-z0-9\-.]{1,20}$/i);
  };
  require('quill-delta-to-html/dist/commonjs/OpToHtmlConverter').OpToHtmlConverter.prototype.getCssStyles = function(size) {
    var attrs = this.op.attributes;
    var propsArr = [['color']];
    var fontSize = [['size']];
    if (!this.options.allowBackgroundClasses) {
      propsArr.push(['background', 'background-color']);
    }
    return propsArr
      .filter(function (item) { return !!attrs[item[0]]; })
      .map(function (item) { return item._preferSecond() + ':' + attrs[item[0]]; })
      .concat(
        fontSize
        .filter(item => !!attrs['size'])
        .map(item => `font-size: ${adjustFontSize(attrs['size'])}`)
      );
  };
  const QuillDeltaToHtmlConverter = require('quill-delta-to-html');

  const CSS_ALL_OF_FONTS = remote.require('./lib/goyo-font-manager').getCssAllofFonts();

  function adjustFontSize(sizeStr) {
    let mo;
    if (mo = sizeStr.match(/(\d*\.?\d*)pt/)) {
      return `${parseFloat(mo[1])}rem`;
    } else if (mo = sizeStr.match(/(\d*\.?\d*)px/)) {
      return `${0.75*parseFloat(mo[1])}rem`;
    }
  }


  class GoyoRichText extends HTMLElement {
    constructor() {
      super();

      this._state = 0;
      let shadow = this.attachShadow({mode: 'open'});
      shadow.appendChild(template.content.cloneNode(true));
    }

    attributeChangedCallback(name, oldValue, newValue) {
      switch (name) {
        default:
          break;
      }
    }

    setText(text) {
      this._text = text;
      this._delta = null;
      this._state = 1;
    }

    setDelta(delta) {
      this._text = null;
      this._delta = delta;
      this._state = 1;
    }

    makeReady() {
      /* This is example of separating text rendering and ruler rendering.
      if (!this.isConnected) return;

      //if (this._state === 1)
      if (this._state === 1 && this.constructor._checkDrawable(this))
      {
        this._make();
        this._state = 2;
      }

      if (this._state === 2 && this.constructor._checkDrawable(this)) {
        let base = this.shadowRoot.querySelector('.base');
        let rect = base.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          this._rect = rect;
          this._computedStyle = window.getComputedStyle(base);
          let target = this.shadowRoot.querySelector('.text');
          this._makeRulerAndRestrictLine(target);
          this._setFontFamilyStyle();
          this._state = 3;
        }
      }
      */

      if (this._state === 1 && this.isConnected && this.constructor._checkDrawable(this)) {
        let base = this.shadowRoot.querySelector('.base');
        let rect = base.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0) {
          this._rect = rect;
          this._computedStyle = window.getComputedStyle(base);
          this._make();

          let target = this.shadowRoot.querySelector('.text');
          this._makeRulerAndRestrictLine(target);
          if (this._delta) {
            this._setFontFamilyStyle();
          }

          this._state = 2;
        }
      }
    }

    /**********************/
    /* Private methods.   */
    /**********************/
    _make() {
      if (this._delta!=null) {
        let delta = this._delta;
        if (this.getAttribute('multiline')==='false') {
          delta = this._extractOneLine(delta);
        }
        let html = this._makeRichText(delta);
        let target = this.shadowRoot.querySelector('.text');
        target.innerHTML = `<div>${html}</div>`;
        //this._makeRulerAndRestrictLine(target);
      } else if (this._text!=null) {
        let text = this._text;
        if (this.getAttribute('multiline')==='false') {
          text = text.split('\n')[0] + '\n';
        } else if (!text.endsWith('\n')) {
          text+='\n';
        }
        text = this._lineAdjustment(text);
        let html = this._prepareWrapPointDetection(text);
        let target = this.shadowRoot.querySelector('.text');
        target.innerHTML = `<div>${html}</div>`;
        //this._makeRulerAndRestrictLine(target);
        //this._setFontFamilyStyle();
      }
    }

    _extractOneLine(deltaOps) {
      let newOps = [];
      for (let op of deltaOps) {
        let idx = op.insert.indexOf('\n');
        if (idx >= 0) {
          let newOp = Object.assign({}, op, { insert: op.insert.slice(0, idx) });
          newOps.push(newOp);
          break;
        } else {
          newOps.push(op);
        }
      }
      return newOps;
    }

    _makeRichText(ops) {
      let valign = this.getAttribute('valign');
      let lines = this.getAttribute('lines');
      if (valign === 'top') {
        ops = ops.concat({ insert: ' \n'.repeat(lines), });
      } else if (valign === 'bottom') {
        ops = [{ insert: ' \n'.repeat(lines) }].concat(ops);
      } else {
        ops = [{ insert: ' \n'.repeat(lines/2) }].concat(ops);
        ops = ops.concat({ insert: ' \n'.repeat(lines/2), });
      }

      let deltaOps = ops.map(op => {
        return {
          insert: this._prepareWrapPointDetection(op.insert, false),
          attributes: op.attributes,
        }
      });
      //if (deltaOps.length>1) {
      //  deltaOps[0].insert = '<ab class="newline"></ab>' + deltaOps[0].insert;
      //}
      let converter = new QuillDeltaToHtmlConverter(deltaOps, {paragraphTag:'div', encodeHtml: false,classPrefix: 'ql'});
      return converter.convert();
    }

    _lineAdjustment(text) {
      let valign = this.getAttribute('valign');
      let lines = this.getAttribute('lines');;
      if (valign === 'top') {
        return text + '\n'.repeat(lines);
      } else if (valign === 'middle') {
        return '\n'.repeat(parseInt(lines/2)) + text + '\n'.repeat(parseInt(lines/2));
        //return text;
      } else if (valign === 'bottom') {
        return '\n'.repeat(lines) + text;
      }
    }

    _prepareWrapPointDetection(text, prefixFirst=true) {
      let arr = Array.from(text).map(ch => {
        if (ch === '\n') {
          return `${ch}<ab class="newline"></ab>`;
        } else {
          return `<ab>${ch}</ab>`;
        }
      });

      return (prefixFirst ? '<ab class="newline"></ab>' : '') + arr.join('');
    }

    _makeRulerAndRestrictLine(elem) {
      let valign = this.getAttribute('valign');

      let abList = elem.querySelectorAll('ab');
      for (let ab of abList) {
        ab.rect = ab.getBoundingClientRect();
      }

      // set 'wrap-point' class into <ab> elements.
      let prev = {};
      let cutoff = false;
      for(let ab of abList) {
        if (cutoff) {
          ab.classList.add('hide');
          continue;
        }

        let bcr = ab.rect;

        if ((valign!=='top') && (bcr.top + bcr.height/8) < this._rect.top) {
          // check whether the <ab> is over the top of parent box.
          ab.classList.add('hide');

        } else if ((valign!=='bottom') && this._rect.bottom < (bcr.bottom - bcr.height/8)) {
          // check whether the <ab> is over the bottom of parent box.
          cutoff = true;
          ab.classList.add('hide');

        } else {
          // check whether the <ab> is wrap point.
          let minWidth = Math.min(prev.width, bcr.width);
          if (bcr.left < prev.right - minWidth/2) {
            // IS wrap point!
            ab.classList.add('wrap-point');
          }
        }
        prev = bcr;
      }

      //// update <style> element.
      //let width = parseInt(this._computedStyle.width);
      //this.shadowRoot.querySelector('style.wrap').textContent = `
      //  .wrap-point::after, .newline::after {
      //    left: -${1*width}px;
      //    width: ${2*width}px;
      //  }
      //`;
    }

    _setFontFamilyStyle() {
      // update <style> element.
this.shadowRoot.querySelector('style.fontfamily').textContent =
CSS_ALL_OF_FONTS;
    }


    /**********************/
    /* Static methods.    */
    /**********************/
    static get observedAttributes() {
      return [
      ];
    }

    static set drawableChecker(v) {
      this._checkDrawable = v;
    }

  }

  GoyoRichText._checkDrawable = () => true;

  customElements.define('goyo-richtext', GoyoRichText);
  return GoyoRichText;
})();
</script>
